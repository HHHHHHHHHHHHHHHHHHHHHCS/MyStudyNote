一点点的优化学习
======

(Github正常排版: [一点点的优化学习][1])

-----------------

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [**0. 起因**](#0-起因)
- [**1. Qualcomm相关**](#1-qualcomm相关)
  - [**1.1. Adreno GPU**](#11-adreno-gpu)
    - [**1.1.1. FlexRender**](#111-flexrender)
    - [**1.1.2. Tile-Based Rendering优化**](#112-tile-based-rendering优化)
    - [**1.1.3. Tile-Based Rendering读写**](#113-tile-based-rendering读写)
    - [**1.1.4. LRZ与深度剔除**](#114-lrz与深度剔除)
  - [**1.2. Vulkan**](#12-vulkan)
    - [**1.2.1. 平台及图形API选择**](#121-平台及图形api选择)
    - [**1.2.2. Memory Property支持**](#122-memory-property支持)
    - [**1.2.3. Secondary command buffer**](#123-secondary-command-buffer)

<!-- /code_chunk_output -->

-----------------

## **0. 起因**

&emsp;&emsp; 五一回家的机票太贵!!! 留下来学习新姿势, 防止玩了五天, 就忘了怎么启动Visual Studio了. 偷偷看视频, 做点笔记, 视频出处404.

-----------------

## **1. Qualcomm相关**

### **1.1. Adreno GPU**

#### **1.1.1. FlexRender**

  + Adreno GPU 支持FlexRender技术. Adreno可以根据画面的复杂度, 在Direction Mode和Binning Mode之间动态切换
  + Direction Mode: 一个RenderPass渲染一次完成, 直接渲染到System Memory
  + Binning Mode: 一个RenderPasss需要分Binning Pass和Rendering Pass两次完成.
    + 把RenderTarget分割为多个小块Tile, Qualcomm把这些Tile称为bin
    + GPU有一个独立的快速缓存为GMEM, bin的大小由GMEM大小除以RenderTarget的格式(包括深度格式)和大小来决定
    + Binning Pass, 执行简化版VS, 获取所有三角形的可见和不可见和位于哪个bin等信息
    + Render Pass, 逐个bin渲染到GMEM, 使用Binning Pass的信息进行粗粒度的剔除, 渲染完毕后Store到System Memory
    + Binning Mode也分两种. Software Binning 和 Hardware Visibility Binning
    + 当顶点数量非常少的时候, 会用Software Binning来渲染, 用CPU来计算Binning信息
  + Hardware Visibility Direction: 先绘制BinningPass, 之后把全部Bin一次性渲染到System Memory
    + 比较新的平台使用, 如8Gen1/2/3等
    + 遮挡关系复杂用BinningPass来处理
    + 如果后面的Bin逐个渲染不如Direction快, 就一次性渲染
  + Snapdragon Profiler, 鼠标停留在Surface的时候, 可以看到用哪个Render Mode
  + 正常情况是驱动自行判断和选择用哪个Render Mode. 但是GL上有hint函数可以指定, VK暂时没有(后续可能会添加)

#### **1.1.2. Tile-Based Rendering优化**
  + 顶点数量通常不是瓶颈, 但是VS里面计算Position过于复杂或者有依赖, 如采样SSBO或Texture, 则会对性能产生较大的影响
    + 因为前面的Rendering Mode会因为Binning Mode出现跑两次VS的情况
    + 优化建议: 使用LOD降低顶点数量
  + HardWare Occlusion Query
    + HardWare Occlusion Query 在Direction Mode比Binning Mode要好很多.
    + 优化建议: 单独把HardWare Occlusion Query放到一个RenderPass, 然后驱动就会检测到这个RenderPass全是Occlusion Query从而去使用到Direction Mode
    + 比如: 先绘制Opaque,AlphaTest,Transparent之后执行GL.Flush. 再执行Occlusion Query. 堡垒之夜因为这个优化性能提升20%.
    + 8Gen3后这个优化就不怎么重要, 因为做了特殊处理
  + Primitive Restart
    + Primitive Restart是什么?[相关链接][2]
    + Primitive Restart对Binning Rendering不友好
    + 优化建议: 不推荐使用

#### **1.1.3. Tile-Based Rendering读写**
  + Load
    + 从System Load FrameBuffer的数据到GMEM, 会触发Load.
    +  第一次切换到某个FBO, 如果没有一个全屏幕的Clear 会触发Load, 因为驱动无法判断数据是否内容是否需要, drawcall是否能覆盖全屏. 而且这次Load的内容可能是undefined, 可能会导致花屏
    + glDiscardFramebufferExt是GLES2.0的API, glInvalidateFrameBuffer是GLES3.0的API. 推荐使用Discard去Clear, 因为Invalidate在很老的驱动上可能有问题
  + Store
    + 从GMEM Store FrameBuffer数据到System Memory
    + 对于不更改或只做比较或后续不使用的FBO, 如某些只比较深度测试的深度图, 就可以使用Discard/Invalidate来避免Store
  + 对于D24S8需要一起Invalidate, 如果只Invalidate Dpeth or Stencil则会失效

#### **1.1.4. LRZ与深度剔除**
  + LRZ(Low Resolution Z)
    + 从Adreno5XX开始支持, 是一张低分辨率深度图, 剔除深度远高于early-z
    + LRZ只在Binning Mode下有效
    + 在Binning Pass构建的时候, 同时构建了LRZ. 在之后真正绘制的时候使用LRZ, 所以和渲染绘制顺序无关
    + Alpha Test物体不会更新LRZ, 比如草
    + 影响LRZ的操作
      + Color Mask操作
      + 中途改变depth compare
      + stencil test的结果依赖于depth test的结果, LRZ不敢剔除, 建议把物体放在之后绘制
      + SSBO, 深度测试失败之后SSBO是否要写或者SSBO不是只读的, LRZ不敢剔除. 如果确定深度测试不过SSBO不写, 可以在Fragment Shader中加early-Z hint
      + MRT, RT是否有相同的读写状态
    + 推荐的绘制顺序
      + Pre-Z, Alpha Test物体且屏占比比较大做Pre-Z, 比如草和树
      + 不透明物体, 一些情况下深度排序仍然比不排序要快, 比如一个巨大的屏风遮住了绝大部分不透明
      + 半透明物体, 比如草和树
      + 透明物体
      + 遮挡查询, 前面加一个flush

### **1.2. Vulkan**

#### **1.2.1. 平台及图形API选择**
  + Adreno5XX开始支持Vulkan, 手游比如堡垒之夜等
  + 晓龙865是一个比较稳定的型号, 可以作为起始版本. 之前老型号如果没有问题可以用Vulkan, 有就建议回退GLES
  + Vulkan驱动的成熟度和时间相关, 和高低配无关. 比如新手机低配的Vulkan支持也是比较成熟的
  + 很多新的feature和extension只在Vulkan下支持

#### **1.2.2. Memory Property支持**
  + Adreno VK驱动支持丰富的memory property, 即VkMemoryPropertyFlagBits
  + 对于需要CPU频繁更新的Buffer, 可以创建为HOST_VISIBLE_BIT对CPU和GPU性能更加有好
  + Unity在高通平台上会有坑(Mesh Skinning GPU)
    + 使用VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT会同时返回两种
    + 第一种 1 = DEVICE_LOCAL
    + 第二种 15 = DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT | HOST_CACHED
    + Unity可能只使用了第一种, 导致CPU GPU性能都降低了
	+ Unity会先申请Storage Buffer, 再vmaMapMemory Mapping一次, 再用vkCmdCopyBuffer拷贝到device上


```C++
typedef enum VkMemoryPropertyFlagBits {
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
	// Provided by VK_VERSION_1_1
	VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
	// Provided by VK_AMD_device_coherent_memory
	VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
	// Provided by VK_AMD_device_coherent_memory
	VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
	// Provided by VK_NV_external_memory_rdma
	VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100,
} VkMemoryPropertyFlagBits;
```

#### **1.2.3. Secondary command buffer**

TODO: 

-----------------
[1]:https://github.com/HHHHHHHHHHHHHHHHHHHHHCS/MyStudyNote/blob/main/MyNote/%E4%B8%80%E7%82%B9%E7%82%B9%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0.md
[2]:https://www.khronos.org/opengl/wiki/Vertex_Rendering#Primitive_Restart