当个触手怪
======

(Github正常排版: [当个触手怪][1])

-----------------


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [**0. 起因**](#0-起因)
- [**1. 原理**](#1-原理)
- [**2. Mimic**](#2-mimic)
  - [**2.1 变量**](#21-变量)

<!-- /code_chunk_output -->


-----------------

## **0. 起因**

之前群里看到一张图, 就好奇实现.

![](Images/Crawler_00.png)

随便想了一下是

1. 从终点位置从高处往下射线, 命中点为落脚点
2. 玩家中心点到落脚点位置生成贝塞尔曲线
3. 代码控制Mesh的生长 
4. 加入触手位置的扰动

然后看看有没有现成的吧! 随便一搜还真有, 而且是免费的, 赛高!!! [资源地址][2]

抄完差不多这样, 开始恶心心 真下头.

虽然只是一个粗略版, 有很多可以调优的地方, 但是还是可以提供一下思路的.

![](Images/Crawler_01.jpg)

-----------------

## **1. 原理**

1. 每帧Update, 如果腿的数量少于阈值就产生新的腿
2. 新的腿的终点.xz = 怪物中心点 + 移动方向 * 产生腿的半径 + 随机数, 新的腿的终点.y 通过xz从高处做射线确定
3. 给腿设置个生命周期, 到期就销毁, 下一帧产生新的腿
4. 通过 怪物中心点 新腿的终点 和 腿的生命周期 生成贝塞尔曲线, 表示腿每个节点的位置
5. 把 每个节点 到 后一个节点 的方向 当作旋转轴, 围绕着生成mesh point, 最后拼接成mesh

当然中间还有很多细节, 比如扰动, 射线检测. 放在后面慢慢讲.

-----------------

## **2. Mimic**

### **2.1 变量**

创建个C#文件 **Mimic.cs**.

```CSharp

using System.Collections.Generic;
using UnityEngine;
using Task = System.Threading.Tasks.Task;

public class Mimic : MonoBehaviour
{
}

```

先想想需要什么变量. Leg类后面补充.

每次移动要产生腿, 腿由很多个触手组成, 触手说白了就是圆环拼成的Mesh.

![](Images/Crawler_02.jpg)


```CSharp

public class Mimic : MonoBehaviour
{
	// 触手的prefab
	public Leg legPrefab;

	// 腿的数量
	[Range(2, 20)] public int numberOfLegs = 5;

	// 腿有几个触手
	[Tooltip("The number of splines per leg")] [Range(1, 10)]
	public int partsPerLeg = 4;

	// 最少需要几个腿站立
	[Range(0, 19)] public int minimumAnchoredLegs = 3;
	// 最少需要触手的数量
	public int minimumAnchoredParts;

	// 腿的生命周期
	[Tooltip("Minimum duration before leg is replaced")]
	public float minLegLifetime = 5;

	[Tooltip("Maximum duration before leg is replaced")]
	public float maxLegLifetime = 15;

	// 新腿的产生半径
	[Tooltip("Leg placement radius offset")]
	public float newLegRadius = 3;

	// 腿的距离
	public float minLegDistance = 4.5f;
	public float maxLegDistance = 6.3f;

	// 触手要细分多少个环
	[Tooltip("Number of spline samples per legpart")] [Range(2, 50)]
	public int legResolution = 40;

	// 触手生长的速度
	[Tooltip("Minimum lerp coeficient for leg growth smoothing")]
	public float minGrowCoef = 4.5f;

	[Tooltip("MAximum lerp coeficient for leg growth smoothing")]
	public float maxGrowCoef = 6.5f;

	// 腿生长的CD
	[Tooltip("Minimum duration before a new leg can be placed")]
	public float newLegCooldown = 0.3f;

	// 移动方向
	public Vector3 legPlacerOrigin;
	// 移动向量
	public Vector3 velocity;
	// 腿的数量
	public int legCount;
	// 触手的数量
	public int deployedLegs;

	private int maxLegs;
	private bool canCreateLeg = true;
	private Queue<Leg> availableLegPool = new();
}

```

-----------------

新版本的Unity提供了ObjectPool 但是我没有去尝试.

这里暂时只做比较麻烦的Mesh模式, 他还有一个利用LineRenderer 现实的Billboard.

-----------------

[1]:https://github.com/HHHHHHHHHHHHHHHHHHHHHCS/MyStudyNote
[2]:https://assetstore.unity.com/publishers/80631