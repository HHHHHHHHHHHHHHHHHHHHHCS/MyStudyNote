UE57自定义顶点
=================

(Github正常排版: [UE57自定义顶点](https://github.com/HHHHHHHHHHHHHHHHHHHHHCS/MyStudyNote/blob/main/MyNote/UE57%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B6%E7%82%B9.md))

(Github插件源码: [MyVertexTool](https://github.com/HHHHHHHHHHHHHHHHHHHHHCS/MyVertexTool))



------------------------


------------------------

## **0. 概述**

&emsp;&emsp; 感觉很久没有写了, 对比上次写还是上次!!! 这一年主要都在学UE, 就来水一篇UE的学习吧. 在各位大佬面前班门弄斧.

因为渲染经常需要模型, 所以模型创建就很关键. 这篇就来点基础的怎么创建模型. 不得不说在Unity创建模型或自定义顶点, 用自定义的 Vertex Shader 非常的简单, 到了UE就直接痛苦面具了!!!

本文分为用Editor创建模型, 还有自定义顶点工厂模型.

**注意** UE 5.5.x 与 5.7.x 在 RHI / RDG 的 Buffer 创建接口上存在差异, 有编译冲突或被标记已过期!

------------------------

## **1. 插件**

&emsp;&emsp; 我习惯用插件形式来做这类比较独立的功能, 便于后续移植与版本升级.

### **1.1. 插件准备**

打开UE 顶部栏Edit -> Plugins -> 左上角Add -> Editor Tool Button , 我这里起名字 MyVertexTool . (起名有点过于随意了, UE这个Plugins创建可选择的模板太多了)

然后打开 {项目}/Plugins/MyVertexTool/MyVertexTool.uplugin, 编辑 **CanContainContent** 的 false 改为 **true**. 在 Modules中, 把 第1个 Module 的 **Type** 的 Editor 改为 **Runtime**. 再在 Modules 中创建一份 Module 命名为 **MyVertexToolEditor**, Type 改为 **Editor** .

Runtime 模块用于运行时数据与渲染逻辑, Editor 模块仅负责编辑器工具.

```
{
	...
	"CanContainContent": true,
	...
	"Modules": [
		{
			"Name": "MyVertexTool",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		},
		{
			"Name": "MyVertexToolEditor",
			"Type": "Editor",
			"LoadingPhase": "Default"
		}
	]
}
```

把 **MyVertexTool** 文件夹拷贝一份命名为 **MyVertexToolEditor**. 删除 **MyVertexTool** 下的所有 *.cpp / *.h / *.cs . 在后文再修改 **MyVertexToolEditor** 相关文件.

重新创建 MyVertexTool/MyVertexTool.Build.cs

```C#
using UnrealBuildTool;

public class MyVertexTool : ModuleRules
{
	public MyVertexTool(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicIncludePaths.AddRange(
			new string[]
			{
			}
		);

		PrivateIncludePaths.AddRange(
			new string[]
			{
			}
		);

		PublicDependencyModuleNames.AddRange(
			new string[]
			{
				"Core",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				"CoreUObject",
				"Engine",
				"Projects",
				"RenderCore"
			}
		);

		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
			}
		);
	}
}
```

重新创建 MyVertexTool/Public/MyVertexTool.h

```C++
#pragma once

#include "Modules/ModuleManager.h"

class FMyVertexToolModule : public IModuleInterface
{
public:

	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};
```

重新创建 MyVertexTool/Private/MyVertexTool.cpp

```C++
#include "MyVertexTool.h"

static const FName MyVertexToolTabName("MyVertexTool");

#define LOCTEXT_NAMESPACE "FMyVertexToolModule"

void FMyVertexToolModule::StartupModule()
{
}

void FMyVertexToolModule::ShutdownModule()
{
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FMyVertexToolModule, MyVertexTool)
```

继续修改 **MyVertexToolEditor**, 修改文件命名, 并且修改全部的 类名/模块名/API 宏/Build.cs 文件

```
MyVertexTool.Build.cs -> MyVertexToolEditor.Build.cs

MyVertexTool.h -> MyVertexToolEditor.h
MyVertexToolCommands.h -> MyVertexToolEditorCommands.h
MyVertexToolStyle.h -> MyVertexToolEditorStyle.h

MyVertexTool.cpp -> MyVertexTool.cpp
MyVertexToolCommands.cpp -> MyVertexToolEditorCommands.cpp
MyVertexToolStyle.cpp -> MyVertexToolEditorStyle.cpp
```

同时需要修改 MyVertexToolEditor.cpp 中的 `IMPLEMENT_MODULE` 宏参数.

```
...
IMPLEMENT_MODULE(FMyVertexToolEditorModule, MyVertexToolEditor)
```

尝试编译, UE启动! 其实还可以进一步规范Editor结构和代码, 这里偷懒不展开细讲, 如果需要可以看下下面几个的修改.

+ MyVertexToolEditorCommands.h 
  + 构造函数
+ MyVertexToolEditorStyle.cpp
  + FMyVertexToolEditorStyle::GetStyleSetName()
  + FMyVertexToolEditorStyle::Create()
+ FMyVertexToolEditorCommands.cpp
  + FMyVertexToolEditorCommands::RegisterCommands()
+ MyVertexToolEditor.cpp
  + static const FName MyVertexToolEditorTabName
  + #define LOCTEXT_NAMESPACE
  + FMyVertexToolEditorModule::PluginButtonClicked()

然后会发现 顶部栏多了一个按钮, 点击会有 弹窗提示. 或者在 顶部 `Windows` 下也多了一个按钮, 点击也有一样的弹窗提示.

![](Images/UE57CustomVertex_00.png)

![](Images/UE57CustomVertex_01.png)

------------------------

## **2. Editor创建模型**

&emsp;&emsp; 先尝试生成创建界面, 再用界面点击按钮 打开保存窗口, 生成 `StaticMesh` 储存到本地, 最后用自定义`CustomNode`用于Pixel渲染.

### **2.1. 插件界面准备**

现在可以用刚生成的插件模板, 点击 `ToolbarMenu` 的按钮, 会弹出一个 `MessageDialog`窗口.

界面分 `Slate` 和 `EditorUtilityWidget` 模式. 因为 `Slate` 写法过于恶心, 所以我个人更喜欢用 `EditorUtilityWidget` 来写界面.

创建 **MyVertexToolEditor/Public/MyVertexToolEditorWidget.h** 继承 **UEditorUtilityWidget**

因为只想做简单一点. 制作 `EditorUtilityWidget`, 其中有一个 `Button`, 点击一下 打开保存窗口, 最后储存 `StaticMesh` 到项目工程.

代码因为个人习惯会先写变量后写方法, 在C++中不是一个好习惯!

```C++
#pragma once

#include "CoreMinimal.h"
#include "EditorUtilityWidget.h"

#include "MyVertexToolEditorWidget.generated.h"

class UEditorUtilityButton;

UCLASS()
class MYVERTEXTOOLEDITOR_API UMyVertexToolEditorWidget : public UEditorUtilityWidget
{
	GENERATED_BODY()

public:
	UPROPERTY(meta=(BindWidget))
	UEditorUtilityButton* Button_CreateMyMesh;
	
public:
	virtual void NativeConstruct() override;

private:
	UFUNCTION()
	void OnClick_CreateMyMesh();

	static bool OpenSaveAssetDialog(FString& outPackagePath, FString& outAssetName);
	void CreateMyMesh(FString packagePath, FString assetName);
};

```

别忘了在 **MyVertexToolEditor.Build.cs** 中添加所需要的依赖`Module`. **UMG** , **UMGEditor** , **Blutility**

```C#
using UnrealBuildTool;

public class MyVertexToolEditor : ModuleRules
{
	public MyVertexToolEditor(ReadOnlyTargetRules Target) : base(Target)
	{
		...

		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				...
				"UMG",
				"UMGEditor",
				"Blutility",
			}
		);

		...
	}
}
```

为了保证编译通过, 先临时添加空的实现. 创建 **MyVertexToolEditor/Private/MyVertexToolEditorWidget.cpp**, 完善申明.

```C++
#include "MyVertexToolEditorWidget.h"

void UMyVertexToolEditorWidget::NativeConstruct()
{
	Super::NativeConstruct();
}

void UMyVertexToolEditorWidget::OnClick_CreateMyMesh()
{
}

bool UMyVertexToolEditorWidget::OpenSaveAssetDialog(FString& outPackagePath, FString& outAssetName)
{
	return true;
}

void UMyVertexToolEditorWidget::CreateMyMesh(FString packagePath, FString assetName)
{
}

```

尝试编译, 启动成功!!!

### **2.2. 插件界面制作**

创建 `Blueprint`, 创建 **MyVertexTool/Editor/Blueprints/EUW_MyVertexToolEditor** 继承 **MyVertexToolEditorWidget** .

大致想法是 顶部居中显示标题 `MyVertexTool`. 下方按顺序放置一个 `Button_CreateMyMesh`. 其余用于后续功能扩展.

由于界面制作, 不好用文章表达, 大致看下面图示.

注意 `Button_CreateMyMesh` 的名字要和代码里面 **Button_CreateMyMesh** 绑定的一致, 因为使用了 `UPROPERTY(meta=(BindWidget))`.

![](Images/UE57CustomVertex_02.png)

![](Images/UE57CustomVertex_03.png)

### **2.3. 插件界面显示**

接下来就是如何让点击一个顶部按钮, 显示刚创建的界面了.

打开 **MyVertexToolEditorModule.h** , 添加接口 **CreateComboToolContent** 和 **OnMenuClicked_VertexTool**

**CreateComboToolContent**, 用于显示 `ToolMenu` 界面

**OnMenuClicked_VertexTool**, 用于创建并且显示插件界面

```C++

class FMyVertexToolEditorModule : public IModuleInterface
{
	...
private:
	void RegisterMenus();

	TSharedRef<SWidget> CreateComboToolContent() const;

	static void OnMenuClicked_VertexTool();
	
	...
};
```

打开 `MyVertexToolEditorModule.cpp`, 先修改 **FMyVertexToolEditorModule::RegisterMenus()** , 创建 **ToolMenus**

UE 这里有一个麻烦的, 如果我想把几个插件的打开界面按钮合并在一个ToolMenu中, 一种做法是单独创建插件用于统一管理 Toolbar UI.

FSlateIcon 位置在 Engine/Content/Editor/Slate 下, 相关可以参考 Engine/Source/Editor/EditorStyle/Private/StarshipStyle.cpp 文件.

```C++
void FMyVertexToolEditorModule::RegisterMenus()
{
	// Owner will be used for cleanup in call to UToolMenus::UnregisterOwner
	FToolMenuOwnerScoped OwnerScoped(this);

	UToolMenu* ToolbarMenu = UToolMenus::Get()->ExtendMenu("LevelEditor.LevelEditorToolBar.PlayToolBar");
	if (!ToolbarMenu)
	{
		return;
	}

	// UE 如果要多个插件使用一个ToolbarMenu, 一种做法是单独创建插件用于统一管理 Toolbar UI
	FToolMenuSection& Section = ToolbarMenu->FindOrAddSection("MyEditorToolsMenu");

	// 如何找到 EditorViewportToolBar.OptionsDropdown 对应的 UI 图标
	// 可以看 Engine/Source/Editor/EditorStyle/Private/StarshipStyle.cpp 查找 EditorViewportToolBar.OptionsDropdown
	// 打开 Engine/Content/Editor/Slate 文件夹, 再根据 IMAGE_BRUSH_SVG("Starship/EditorViewport/menu") 就是对应的UI
	const FUIAction PlatformMenuShownDelegate;
	FToolMenuEntry Entry = FToolMenuEntry::InitComboButton(
		"MyEditorToolsMenu",
		PlatformMenuShownDelegate,
		FOnGetContent::CreateLambda([this] { return CreateComboToolContent(); }),
		LOCTEXT("MyEditorTools", "MyEditorTools"),
		LOCTEXT("MyEditorTools_Tooltip", "MyEditorTools_Tooltip"),
		FSlateIcon(FAppStyle::GetAppStyleSetName(), "EditorViewportToolBar.OptionsDropdown"),
		false,
		"PlatformsMenu");
	Entry.StyleNameOverride = "CalloutToolbar";
	Section.AddEntry(Entry);
}
```

继续完善 **FMyVertexToolEditorModule::CreateComboToolContent()**

这里创建 **ToolMenus** 的子选项 **ToolMenuSection**

```C++
...
TSharedRef<SWidget> FMyVertexToolEditorModule::CreateComboToolContent() const
{
	static const FName MenuName("LevelEditor.MainMenu.Window.MyEditorToolsMenu");
	if (!UToolMenus::Get()->IsMenuRegistered(MenuName))
	{
		UToolMenu* Menu = UToolMenus::Get()->RegisterMenu(MenuName);
		// 可以添加不同的selection, 分割用
		// FToolMenuSection& ManagePlatformsSection = Menu->AddSection("MyToolsMenu_Other", LOCTEXT("MyEditorTools_Other", "MyEditorTools/Other"));
		FToolMenuSection& ManagePlatformsSection = Menu->AddSection("MyToolsMenu", LOCTEXT("MyEditorTools", "MyEditorTools"));
		ManagePlatformsSection.AddDynamicEntry(
			FName("MyEditorTools"),
			FNewToolMenuSectionDelegate::CreateLambda([](FToolMenuSection& PlatformsSection)
			{
				PlatformsSection.AddMenuEntry(
					NAME_None,
					LOCTEXT("VertexToolMenu", "VertexToolMenu"),
					LOCTEXT("VertexToolMenu_Tooltip", "VertexToolMenu"),
					FSlateIcon(FAppStyle::GetAppStyleSetName(), "LevelEditor.Tabs.Viewports"),
					FUIAction(
						FExecuteAction::CreateStatic(&FMyVertexToolEditorModule::OnMenuClicked_VertexTool))
				);

				// 如果是UI合集插件, 这里可以继续添加按钮
			}));
	}

	const FToolMenuContext MenuContext(PluginCommands);

	return UToolMenus::Get()->GenerateWidget(MenuName, MenuContext);
}
...
```

最后完善 **FMyVertexToolEditorModule::OnMenuClicked_VertexTool()**

这里用于点击Section, 显示`EUW_MyVertexToolEditor` 界面

别忘了添加两个include

蓝图的路径可以 选中资源 -> ctrl+c 或者 选中资源 -> 右键 -> Copy Reference

```C++
#include "EditorUtilitySubsystem.h"
#include "EditorUtilityWidgetBlueprint.h"

...
void FMyVertexToolEditorModule::OnMenuClicked_VertexTool()
{
	UEditorUtilitySubsystem* EditorUtilitySubsystem = GEditor->GetEditorSubsystem<UEditorUtilitySubsystem>();
	if (!EditorUtilitySubsystem)
	{
		UE_LOG(LogTemp, Warning, TEXT("Failed to get EditorUtilitySubsystem"));
		return;
	}
	const FString BlueprintPathStr = TEXT("/Script/Blutility.EditorUtilityWidgetBlueprint'/MyVertexTool/Editor/Blueprints/EUW_MyVertexToolEditor.EUW_MyVertexToolEditor'");
	const FSoftObjectPath BlueprintPath = BlueprintPathStr;
	UObject* BlueprintObject = BlueprintPath.TryLoad();
	UEditorUtilityWidgetBlueprint* LoadedEditorUtilityBlueprint = Cast<UEditorUtilityWidgetBlueprint>(BlueprintObject);
	EditorUtilitySubsystem->SpawnAndRegisterTabWithId(LoadedEditorUtilityBlueprint, FName(TEXT("MyVertexTool")));
}
```

编译启动!!! 点击按钮 显示EUW蓝图界面. 到此为止已经完成了界面的显示和绑定.

![](Images/UE57CustomVertex_04.png)

### **2.4. 创建模型**

先完成 `Button` 事件的绑定和相关流程. 点击按钮 -> 资源保存窗口 -> 返回资源路径和名称 -> 保存到本地.

继续完善 **MyVertexToolEditorWidget.cpp** , 修改之前添加空的申明.

别忘了添加include.

```C++
...
#include "EditorUtilityWidgetComponents.h"

void UMyVertexToolEditorWidget::NativeConstruct()
{
	Super::NativeConstruct();
	
	if (IsValid(Button_CreateMyMesh))
	{
		Button_CreateMyMesh->OnClicked.AddDynamic(this, &UMyVertexToolEditorWidget::OnClick_CreateMyMesh);
	}
}

void UMyVertexToolEditorWidget::OnClick_CreateMyMesh()
{
	FString outPackagePath;
	FString outAssetName;
	bool canSave = OpenSaveAssetDialog(outPackagePath, outAssetName);

	if (!canSave)
	{
		return;
	}

	CreateMyMesh(outPackagePath, outAssetName);
}

```

然后完善 **UMyRainToolsWidget::OpenSaveAssetDialog()** 弹出窗口保存相关.

注意保存的文件要在 `Content` 目录下, 而且最后要转换成UE的虚拟路径.

```C++
...
#include "DesktopPlatformModule.h"

...

bool UMyVertexToolEditorWidget::OpenSaveAssetDialog(FString& outPackagePath, FString& outAssetName)
{
	IDesktopPlatform* desktopPlatform = FDesktopPlatformModule::Get();
	if (!desktopPlatform)
	{
		return false;
	}

	void* parentWindowHandle = nullptr;

	const FString defaultPath = FPaths::ProjectContentDir();
	const FString defaultFile = TEXT("MyMeshAsset");

	TArray<FString> outFiles;

	bool bResult = desktopPlatform->SaveFileDialog(
		parentWindowHandle,
		TEXT("Save Asset"),
		defaultPath,
		defaultFile,
		TEXT("Unreal Asset (*.uasset)|*.uasset"),
		EFileDialogFlags::None,
		outFiles
	);

	if (!bResult || outFiles.Num() == 0)
	{
		return false;
	}

	FString fullPath = outFiles[0];

	// 必须在 Content 目录下
	if (!fullPath.StartsWith(FPaths::ProjectContentDir()))
	{
		UE_LOG(LogTemp, Error, TEXT("Asset must be saved under Content folder"));
		return false;
	}

	// 磁盘路径 -> /Game/ 路径
	FString relativePath = fullPath;
	FPaths::MakePathRelativeTo(relativePath, *FPaths::ProjectContentDir());

	FString packagePath = TEXT("/Game/") + FPaths::GetPath(relativePath);
	FString assetName = FPaths::GetBaseFilename(relativePath);

	outPackagePath = packagePath;
	outAssetName = assetName;
	return true;
}

```

有了路径之后就是完成模型的 数据初始化 创建 和 保存 了.

这里写以稍微复杂点的模型 双锥体. 注意 UE的尺寸单位是cm 对比Unity 要x100, UV 是翻转的, z轴是向上的.

这里 只用 Index, Vertex, UV, Tangent 和 Normal 准备用自动生成. 

```C++
...
#include "StaticMeshAttributes.h"
#include "AssetRegistry/AssetRegistryModule.h"

...

void UMyVertexToolEditorWidget::CreateMyMesh(FString packagePath, FString assetName)
{
	constexpr float k_MeshHeight = 4.0f;
	constexpr float k_MeshRadius = 1.0f;
	constexpr int32 k_MeshWNum = 30;
	constexpr int32 k_MeshHNum = 13;

	FVector3f vertexs[k_MeshWNum + 1][k_MeshHNum * 2 + 1];
	FVector2f uvs[k_MeshWNum + 1][k_MeshHNum * 2 + 1];
	float delta = 2.0f * PI / k_MeshWNum;
	for (int32 i = 0; i < k_MeshWNum + 1; i++)
	{
		float a = i * delta;
		if (i == k_MeshWNum)
		{
			a = 0;
		}

		float x = FMath::Sin(a);
		float z = FMath::Cos(a);
		for (int j = -k_MeshHNum; j <= k_MeshHNum; j++)
		{
			float y = k_MeshHeight * j / k_MeshHNum;

			float r = (1 - (float)FMath::Abs(j) / k_MeshHNum) * k_MeshRadius;
			// 注意向上的轴是z, 尺寸单位是 cm 所以x100
			vertexs[i][j + k_MeshHNum] = 100.0f * FVector3f(x * r, z * r, y);

			FVector2f uv = FVector2f(
				4.0f * i / k_MeshWNum,
				(float)j / k_MeshHNum);

			// 因为UE UV Y 和 Unity 不太一样
			uv.Y = -uv.Y;

			uvs[i][j + k_MeshHNum] = uv;
		}
	}

	constexpr int32 k_VertexCount = (k_MeshWNum + 1) * (2 * k_MeshHNum + 1);
	constexpr int32 k_IndicesCount = k_MeshWNum * (2 * k_MeshHNum) * 6;

	// 把二维数组转换为一线性数据
	TArray<FVector3f> vertArray;
	vertArray.SetNum(k_VertexCount);
	TArray<FVector2f> uvArray;
	uvArray.SetNum(k_VertexCount);
	TArray<int32> indexArray;
	indexArray.SetNum(k_IndicesCount);

	int32 currIdx = 0;
	for (int32 i = 0; i < k_MeshWNum + 1; i++)
	{
		for (int32 j = 0; j < k_MeshHNum * 2 + 1; j++)
		{
			int32 idx = i * (k_MeshHNum * 2 + 1) + j;
			vertArray[idx] = vertexs[i][j];
			uvArray[idx] = uvs[i][j];
			currIdx++;
		}
	}

	currIdx = 0;
	for (int32 i = 0; i < k_MeshWNum; i++)
	{
		for (int32 j = 0; j < k_MeshHNum * 2; j++)
		{
			// Quad的四个顶点
			int32 i0 = i * (k_MeshHNum * 2 + 1) + j;
			int32 i1 = i * (k_MeshHNum * 2 + 1) + (j + 1);
			int32 i2 = (i + 1) * (k_MeshHNum * 2 + 1) + (j + 1);
			int32 i3 = (i + 1) * (k_MeshHNum * 2 + 1) + j;

			// Triangle 1: v2 v1 v0
			indexArray[currIdx + 0] = i2;
			indexArray[currIdx + 1] = i1;
			indexArray[currIdx + 2] = i0;
			// Triangle 2: v3 v2 v0
			indexArray[currIdx + 3] = i3;
			indexArray[currIdx + 4] = i2;
			indexArray[currIdx + 5] = i0;

			currIdx += 6;
		}
	}

	// TODO:
}

```

数据准备完了, 开始导入数据给mesh.

先导入 `Position` 数据, 再 `CreatePolygonGroup`, 利用 `Polygon` 创建UV.

```C++

void UMyVertexToolEditorWidget::CreateMyMesh(FString packagePath, FString assetName)
{
	...

	FMeshDescription meshDesc;
	FStaticMeshAttributes attributes{meshDesc};
	attributes.Register();

	TVertexAttributesRef<FVector3f> posRef = attributes.GetVertexPositions();
	TMap<int32, FVertexID> vertexIDs;
	for (int i = 0; i < vertArray.Num(); i++)
	{
		FVertexID vertexID = meshDesc.CreateVertex();
		vertexIDs.Add(i, vertexID);
		posRef[vertexID] = vertArray[i];
	}

	FPolygonGroupID polyGroup = meshDesc.CreatePolygonGroup();
	// 设置polygon name, 之后设置材质要和这个name一样
	attributes.GetPolygonGroupMaterialSlotNames()[polyGroup] = FName("Default");

	TVertexInstanceAttributesRef<FVector2f> uvs0Ref = attributes.GetVertexInstanceUVs();
	uvs0Ref.SetNumChannels(1);

	const int32 k_PolygonTypeNum = 3;
	TArray<FVertexInstanceID> instanceIDs;
	instanceIDs.SetNum(k_PolygonTypeNum);

	currIdx = 0;
	for (int i = 0; i < indexArray.Num() / k_PolygonTypeNum; i++)
	{
		for (int j = 0; j < k_PolygonTypeNum; j++)
		{
			int32 idx = indexArray[currIdx];
			FVertexID vertexID = vertexIDs[idx];
			FVertexInstanceID vi = meshDesc.CreateVertexInstance(vertexID);
			instanceIDs[j] = vi;
			uvs0Ref.Set(vi, 0, uvArray[idx]);
			currIdx++;
		}

		meshDesc.CreatePolygon(polyGroup, instanceIDs);
	}

	// TODO:
}

```

接下来就创建 `UStaticMesh` .

UE 重写了 '/', 可以用写拼接路径. 在该路径下实例化一个 `NewObject<UStaticMesh>` , 然后再初始化 Resource 和 Models. `RF_Public | RF_Standalone` 标志, 以确保该资源可以被正常保存 引用并显示在内容浏览器中.

构建Model, 构建参数里 标记了 重建 `Normal` 和 `Tangent` , 并且 移除未已引用的三角形(虽然这里没有未引用的三角形). 

再给Mesh提供默认的材质, 注意 `MaterialSlotNames` **Default** 要和上面的 `PolygonGroupMaterialSlotNames` 一致.

在构建 `FBuildMeshDescriptionsParams`, 因为直接用于渲染 不需要 CPU 做读写, 
所以 `bAllowCpuAccess` 为 **false** . 之后就是利用 `BuildFromMeshDescriptions` 创建 之前的参数 根据 Mesh 生成 渲染资源

最后, 调用 `MarkPackageDirty` 标记资源包发生修改, 并通过 `AssetRegistry` 通知编辑器系统有新的资产被创建.

```C++

void UMyVertexToolEditorWidget::CreateMyMesh(FString packagePath, FString assetName)
{
	...

	// UE 重写了 '/', 这里的作用是路径拼接
	FString fullPackageName = packagePath / assetName;
	UPackage* package = CreatePackage(*fullPackageName);

	UStaticMesh* staticMesh = NewObject<UStaticMesh>(
		package,
		*assetName,
		RF_Public | RF_Standalone);

	// staticMesh->bSupportRayTracing = 0;
	staticMesh->InitResources();
	staticMesh->SetNumSourceModels(1);

	FStaticMeshSourceModel& srcModel = staticMesh->GetSourceModel(0);
	srcModel.BuildSettings.bRecomputeNormals = true;
	srcModel.BuildSettings.bRecomputeTangents = true;
	srcModel.BuildSettings.bRemoveDegenerates = true;

	UMaterialInterface* defaultMaterial = UMaterial::GetDefaultMaterial(MD_Surface);
	staticMesh->GetStaticMaterials().Add(FStaticMaterial(defaultMaterial, FName("Default")));

	UStaticMesh::FBuildMeshDescriptionsParams params;
	params.bFastBuild = false;
	params.bUseHashAsGuid = true;
	params.bMarkPackageDirty = true;
	params.bCommitMeshDescription = true;
	params.bAllowCpuAccess = false;
	staticMesh->BuildFromMeshDescriptions({&meshDesc}, params);

	staticMesh->MarkPackageDirty();

	FAssetRegistryModule::AssetCreated(staticMesh);
}

```

最后别忘记在 **MyVertexToolEditor.Build.cs** 中补充依赖的Module: DesktopPlatform, MeshDescription, StaticMeshDescription, AssetRegistry.

```C#
...
public MyVertexToolEditor(ReadOnlyTargetRules Target) : base(Target)
{
	...
	PrivateDependencyModuleNames.AddRange(
		new string[]
		{
			...
			"DesktopPlatform",
			"MeshDescription",
			"StaticMeshDescription",
			"AssetRegistry",
			// ... add private dependencies that you statically link with here ...	
		}
	);
	...
}

```

编译启动. 点击按钮 创建Mesh 再保存到本地, 之后把它拖入场景, 给一个材质, 大功告成!

![](Images/UE57CustomVertex_05.png)


### **2.5. 支持覆盖**

到此为止基本已经结束了, 但是还存在一个问题就是如果我要覆盖以有模型就会报错Crash.

> Error: A FRenderResource was deleted without being released first!

我暂时的解决办法就是修改之前以有的模型, 而不是做资源覆盖.

继续修改 **UMyVertexToolEditorWidget::CreateMyMesh()**

判断资源是否已经存在. 如果存在 就执行 NewObject. 否则就 Modify, 注意释放资源, 记得要等待渲染线程执行结束并且释放资源.

```C++
void UMyVertexToolEditorWidget::CreateMyMesh(FString packagePath, FString assetName)
{
	...
	// UE 重写了 '/', 这里的作用是路径拼接
	FString fullPackageName = packagePath / assetName;
	UPackage* package = CreatePackage(*fullPackageName);

	// 判断是否存在, 如果存在就做修改, 不存在就New
	UStaticMesh* staticMesh = FindObject<UStaticMesh>(package, *assetName);
	const bool bIsNewAsset = (staticMesh == nullptr);
	
	if (bIsNewAsset)
	{
		staticMesh = NewObject<UStaticMesh>(package, *assetName, RF_Public | RF_Standalone);
	}
	else
	{
		// 先释放资源, 注意要等待 然后释放渲染资源
		staticMesh->Modify(); // 记录修改
		staticMesh->ReleaseResources();
		FlushRenderingCommands(); // 等渲染线程彻底放掉旧资源
		staticMesh->GetStaticMaterials().Reset();
	}

	...
}
```

编译启动! 再次尝试替换资源, 保存. 执行成功!

自此 用Editor 创建Mesh 已经结束了.