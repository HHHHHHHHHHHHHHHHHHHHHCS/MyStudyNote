UE57自定义顶点
=================

(Github正常排版: [UE57自定义顶点](https://github.com/HHHHHHHHHHHHHHHHHHHHHCS/MyStudyNote/blob/main/MyNote/UE57%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B6%E7%82%B9.md))

(Github插件源码: [MyVertexTool](https://github.com/HHHHHHHHHHHHHHHHHHHHHCS/MyVertexTool))



------------------------


------------------------

## **0. 概述**

&emsp;&emsp; 感觉很久没有写了, 对比上次写还是上次!!! 这一年主要都在学UE, 就来水一篇UE的学习吧. 在各位大佬面前班门弄斧.

因为渲染经常需要模型, 所以模型创建就很关键. 这篇就来点基础的怎么创建模型. 不得不说在Unity创建模型或自定义顶点, 用自定义的 Vertex Shader 非常的简单, 到了UE就直接痛苦面具了!!!

本文分为用Editor创建模型, 还有自定义顶点工厂模型.

**注意** UE 5.5.x 与 5.7.x 在 RHI / RDG 的 Buffer 创建接口上存在差异, 有编译冲突或被标记已过期!

------------------------

## **1. 插件**

&emsp;&emsp; 我习惯用插件形式来做这类比较独立的功能, 便于后续移植与版本升级.

### **1.1. 插件准备**

打开UE 顶部栏Edit -> Plugins -> 左上角Add -> Editor Tool Button , 我这里起名字 MyVertexTool . (起名有点过于随意了, UE这个Plugins创建可选择的模板太多了)

然后打开 {项目}/Plugins/MyVertexTool/MyVertexTool.uplugin, 编辑 **CanContainContent** 的 false 改为 **true**. 在 Modules中, 把 第1个 Module 的 **Type** 的 Editor 改为 **Runtime**. 再在 Modules 中创建一份 Module 命名为 **MyVertexToolEditor**, Type 改为 **Editor** .

Runtime 模块用于运行时数据与渲染逻辑, Editor 模块仅负责编辑器工具.

```
{
	...
	"CanContainContent": true,
	...
	"Modules": [
		{
			"Name": "MyVertexTool",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		},
		{
			"Name": "MyVertexToolEditor",
			"Type": "Editor",
			"LoadingPhase": "Default"
		}
	]
}
```

把 **MyVertexTool** 文件夹拷贝一份命名为 **MyVertexToolEditor**. 删除 **MyVertexTool** 下的所有 *.cpp / *.h / *.cs . 在后文再修改 **MyVertexToolEditor** 相关文件.

重新创建 MyVertexTool/MyVertexTool.Build.cs

```C#
using UnrealBuildTool;

public class MyVertexTool : ModuleRules
{
	public MyVertexTool(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicIncludePaths.AddRange(
			new string[]
			{
			}
		);

		PrivateIncludePaths.AddRange(
			new string[]
			{
			}
		);

		PublicDependencyModuleNames.AddRange(
			new string[]
			{
				"Core",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				"CoreUObject",
				"Engine",
				"Projects",
				"RenderCore"
			}
		);

		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
			}
		);
	}
}
```

重新创建 MyVertexTool/Public/MyVertexTool.h

```C++
#pragma once

#include "Modules/ModuleManager.h"

class FMyVertexToolModule : public IModuleInterface
{
public:

	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};
```

重新创建 MyVertexTool/Private/MyVertexTool.cpp

```C++
#include "MyVertexTool.h"

static const FName MyVertexToolTabName("MyVertexTool");

#define LOCTEXT_NAMESPACE "FMyVertexToolModule"

void FMyVertexToolModule::StartupModule()
{
}

void FMyVertexToolModule::ShutdownModule()
{
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FMyVertexToolModule, MyVertexTool)
```

继续修改 **MyVertexToolEditor**, 修改文件命名, 并且修改全部的 类名/模块名/API 宏/Build.cs 文件

```
MyVertexTool.Build.cs -> MyVertexToolEditor.Build.cs

MyVertexTool.h -> MyVertexToolEditor.h
MyVertexToolCommands.h -> MyVertexToolEditorCommands.h
MyVertexToolStyle.h -> MyVertexToolEditorStyle.h

MyVertexTool.cpp -> MyVertexTool.cpp
MyVertexToolCommands.cpp -> MyVertexToolEditorCommands.cpp
MyVertexToolStyle.cpp -> MyVertexToolEditorStyle.cpp
```

同时需要修改 MyVertexToolEditor.cpp 中的 `IMPLEMENT_MODULE` 宏参数.

```
...
IMPLEMENT_MODULE(FMyVertexToolEditorModule, MyVertexToolEditor)
```

尝试编译, UE启动! 其实还可以进一步规范Editor结构和代码, 这里偷懒不展开细讲, 如果需要可以看下下面几个的修改.

+ MyVertexToolEditorCommands.h 
  + 构造函数
+ MyVertexToolEditorStyle.cpp
  + FMyVertexToolEditorStyle::GetStyleSetName()
  + FMyVertexToolEditorStyle::Create()
+ FMyVertexToolEditorCommands.cpp
  + FMyVertexToolEditorCommands::RegisterCommands()
+ MyVertexToolEditor.cpp
  + static const FName MyVertexToolEditorTabName
  + #define LOCTEXT_NAMESPACE
  + FMyVertexToolEditorModule::PluginButtonClicked()

然后会发现 顶部栏多了一个按钮, 点击会有 弹窗提示. 或者在 顶部 `Windows` 下也多了一个按钮, 点击也有一样的弹窗提示.

![](Images/UE57CustomVertex_00.png)

![](Images/UE57CustomVertex_01.png)

------------------------

## **2. Editor创建模型**

&emsp;&emsp; 先尝试生成创建界面, 再用界面点击按钮 打开保存窗口, 生成 `StaticMesh` 储存到本地, 最后用自定义`CustomNode`用于Pixel渲染.

### **2.1. 插件界面准备**

现在可以用刚生成的插件模板, 点击 `ToolbarMenu` 的按钮, 会弹出一个 `MessageDialog`窗口.

界面分 `Slate` 和 `EditorUtilityWidget` 模式. 因为 `Slate` 写法过于恶心, 所以我个人更喜欢用 `EditorUtilityWidget` 来写界面.

创建 **MyVertexToolEditor/Public/MyVertexToolEditorWidget.h** 继承 **UEditorUtilityWidget**

因为只想做简单一点. 制作 `EditorUtilityWidget`, 其中有一个 `Button`, 点击一下 打开保存窗口, 最后储存 `StaticMesh` 到项目工程.

```C++
#pragma once

#include "CoreMinimal.h"
#include "EditorUtilityWidget.h"

#include "MyVertexToolEditorWidget.generated.h"

class UEditorUtilityButton;

UCLASS()
class MYVERTEXTOOLEDITOR_API UMyVertexToolEditorWidget : public UEditorUtilityWidget
{
	GENERATED_BODY()

public:
	UPROPERTY(meta=(BindWidget))
	UEditorUtilityButton* Button_CreateMyMesh;
	
public:
	virtual void NativeConstruct() override;

private:
	UFUNCTION()
	void OnClick_CreateMyMesh();

	static bool OpenSaveAssetDialog(FString& outPackagePath, FString& outAssetName);
	void CreateMyMesh(FString packagePath, FString assetName);
};

```

别忘了在 **MyVertexToolEditor.Build.cs** 中添加所需要的依赖`Module`. **UMG** , **UMGEditor** , **Blutility**

```C#
using UnrealBuildTool;

public class MyVertexToolEditor : ModuleRules
{
	public MyVertexToolEditor(ReadOnlyTargetRules Target) : base(Target)
	{
		...

		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				...
				"UMG",
				"UMGEditor",
				"Blutility",
			}
		);

		...
	}
}
```

为了保证编译通过, 先临时添加空的实现. 创建 **MyVertexToolEditor/Private/MyVertexToolEditorWidget.cpp**, 完善申明.

```C++
#include "MyVertexToolEditorWidget.h"

void UMyVertexToolEditorWidget::NativeConstruct()
{
	Super::NativeConstruct();
}

void UMyVertexToolEditorWidget::OnClick_CreateMyMesh()
{
}

bool UMyVertexToolEditorWidget::OpenSaveAssetDialog(FString& outPackagePath, FString& outAssetName)
{
	return true;
}

void UMyVertexToolEditorWidget::CreateMyMesh(FString packagePath, FString assetName)
{
}

```

尝试编译, 启动成功!!!

### **2.2. 插件界面制作**

创建 `Blueprint`, 创建 **MyVertexTool/Editor/Blueprints/EUW_MyVertexToolEditor** 继承 **MyVertexToolEditorWidget** .

大致想法是 顶部居中显示标题 `MyVertexTool`. 下方按顺序放置一个 `Button_CreateMyMesh`. 其余用于后续功能扩展.

由于界面制作, 不好用文章表达, 大致看下面图示.

注意 `Button_CreateMyMesh` 的名字要和代码里面 **Button_CreateMyMesh** 绑定的一致性.

![](Images/UE57CustomVertex_02.png)

![](Images/UE57CustomVertex_03.png)

### **2.3. 插件界面显示**

接下来就是如何让点击一个顶部按钮, 显示刚创建的界面了.

打开 **MyVertexToolEditorModule.h** , 添加接口 **CreateComboToolContent** 和 **OnMenuClicked_VertexTool**

**CreateComboToolContent**, 用于显示 `ToolMenu` 界面

**OnMenuClicked_VertexTool**, 用于创建并且显示插件界面

```C++

class FMyVertexToolEditorModule : public IModuleInterface
{
	...
private:
	void RegisterMenus();

	TSharedRef<SWidget> CreateComboToolContent() const;

	static void OnMenuClicked_VertexTool();
	
	...
};
```

打开 `MyVertexToolEditorModule.cpp`, 先修改 **FMyVertexToolEditorModule::RegisterMenus()** , 创建 **ToolMenus**

UE 这里有一个麻烦的, 如果我想把几个插件的打开界面按钮合并在一个ToolMenu中, 一种做法是单独创建插件用于统一管理 Toolbar UI.

FSlateIcon 位置在 Engine/Content/Editor/Slate 下, 相关可以参考 Engine/Source/Editor/EditorStyle/Private/StarshipStyle.cpp 文件.

```C++
void FMyVertexToolEditorModule::RegisterMenus()
{
	// Owner will be used for cleanup in call to UToolMenus::UnregisterOwner
	FToolMenuOwnerScoped OwnerScoped(this);

	UToolMenu* ToolbarMenu = UToolMenus::Get()->ExtendMenu("LevelEditor.LevelEditorToolBar.PlayToolBar");
	if (!ToolbarMenu)
	{
		return;
	}

	// UE 如果要多个插件使用一个ToolbarMenu, 一种做法是单独创建插件用于统一管理 Toolbar UI
	FToolMenuSection& Section = ToolbarMenu->FindOrAddSection("MyEditorToolsMenu");

	// 如何找到 EditorViewportToolBar.OptionsDropdown 对应的 UI 图标
	// 可以看 Engine/Source/Editor/EditorStyle/Private/StarshipStyle.cpp 查找 EditorViewportToolBar.OptionsDropdown
	// 打开 Engine/Content/Editor/Slate 文件夹, 再根据 IMAGE_BRUSH_SVG("Starship/EditorViewport/menu") 就是对应的UI
	const FUIAction PlatformMenuShownDelegate;
	FToolMenuEntry Entry = FToolMenuEntry::InitComboButton(
		"MyEditorToolsMenu",
		PlatformMenuShownDelegate,
		FOnGetContent::CreateLambda([this] { return CreateComboToolContent(); }),
		LOCTEXT("MyEditorTools", "MyEditorTools"),
		LOCTEXT("MyEditorTools_Tooltip", "MyEditorTools_Tooltip"),
		FSlateIcon(FAppStyle::GetAppStyleSetName(), "EditorViewportToolBar.OptionsDropdown"),
		false,
		"PlatformsMenu");
	Entry.StyleNameOverride = "CalloutToolbar";
	Section.AddEntry(Entry);
}
```

继续完善 **FMyVertexToolEditorModule::CreateComboToolContent()**

这里创建 **ToolMenus** 的子选项 **ToolMenuSection**

```C++
...
TSharedRef<SWidget> FMyVertexToolEditorModule::CreateComboToolContent() const
{
	static const FName MenuName("LevelEditor.MainMenu.Window.MyEditorToolsMenu");
	if (!UToolMenus::Get()->IsMenuRegistered(MenuName))
	{
		UToolMenu* Menu = UToolMenus::Get()->RegisterMenu(MenuName);
		// 可以添加不同的selection, 分割用
		// FToolMenuSection& ManagePlatformsSection = Menu->AddSection("MyToolsMenu_Other", LOCTEXT("MyEditorTools_Other", "MyEditorTools/Other"));
		FToolMenuSection& ManagePlatformsSection = Menu->AddSection("MyToolsMenu", LOCTEXT("MyEditorTools", "MyEditorTools"));
		ManagePlatformsSection.AddDynamicEntry(
			FName("MyEditorTools"),
			FNewToolMenuSectionDelegate::CreateLambda([](FToolMenuSection& PlatformsSection)
			{
				PlatformsSection.AddMenuEntry(
					NAME_None,
					LOCTEXT("VertexToolMenu", "VertexToolMenu"),
					LOCTEXT("VertexToolMenu_Tooltip", "VertexToolMenu"),
					FSlateIcon(FAppStyle::GetAppStyleSetName(), "LevelEditor.Tabs.Viewports"),
					FUIAction(
						FExecuteAction::CreateStatic(&FMyVertexToolEditorModule::OnMenuClicked_VertexTool))
				);

				// 如果是UI合集插件, 这里可以继续添加按钮
			}));
	}

	const FToolMenuContext MenuContext(PluginCommands);

	return UToolMenus::Get()->GenerateWidget(MenuName, MenuContext);
}
...
```

最后完善 **FMyVertexToolEditorModule::OnMenuClicked_VertexTool()**

这里用于点击Section, 显示`EUW_MyVertexToolEditor` 界面

别忘了添加两个include

蓝图的路径可以 选中资源 -> ctrl+c 或者 选中资源 -> 右键 -> Copy Reference

```C++
#include "EditorUtilitySubsystem.h"
#include "EditorUtilityWidgetBlueprint.h"

...
void FMyVertexToolEditorModule::OnMenuClicked_VertexTool()
{
	UEditorUtilitySubsystem* EditorUtilitySubsystem = GEditor->GetEditorSubsystem<UEditorUtilitySubsystem>();
	if (!EditorUtilitySubsystem)
	{
		UE_LOG(LogTemp, Warning, TEXT("Failed to get EditorUtilitySubsystem"));
		return;
	}
	const FString BlueprintPathStr = TEXT("/Script/Blutility.EditorUtilityWidgetBlueprint'/MyVertexTool/Editor/Blueprints/EUW_MyVertexToolEditor.EUW_MyVertexToolEditor'");
	const FSoftObjectPath BlueprintPath = BlueprintPathStr;
	UObject* BlueprintObject = BlueprintPath.TryLoad();
	UEditorUtilityWidgetBlueprint* LoadedEditorUtilityBlueprint = Cast<UEditorUtilityWidgetBlueprint>(BlueprintObject);
	EditorUtilitySubsystem->SpawnAndRegisterTabWithId(LoadedEditorUtilityBlueprint, FName(TEXT("MyVertexTool")));
}
```

编译启动!!! 点击按钮 显示EUW蓝图界面.

![](Images/UE57CustomVertex_04.png)
