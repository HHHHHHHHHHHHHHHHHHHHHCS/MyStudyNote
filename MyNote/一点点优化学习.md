一点点优化学习
======

(Github正常排版: [一点点优化][1])

-----------------


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [**0. 起因**](#0-起因)
- [**1. Qualcomm相关**](#1-qualcomm相关)
  - [**1.1. Adreno GPU**](#11-adreno-gpu)
    - [**1.1.1. FlexRender**](#111-flexrender)
    - [**1.1.2. Tile-Based Rendering优化**](#112-tile-based-rendering优化)
    - [**1.1.3. Tile-Based Rendering读写**](#113-tile-based-rendering读写)

<!-- /code_chunk_output -->



-----------------

## **0. 起因**

&emsp;&emsp; 五一回家的机票太贵!!! 留下来学习新姿势, 防止玩了五天, 就忘了怎么启动Visual Studio了. 偷偷看视频, 做点笔记, 视频出处404.

-----------------

## **1. Qualcomm相关**

### **1.1. Adreno GPU**

#### **1.1.1. FlexRender**

  + Adreno GPU 支持FlexRender技术. Adreno可以根据画面的复杂度, 在Direction Mode和Binning Mode之间动态切换
  + Direction Mode: 一个RenderPass渲染一次完成, 直接渲染到System Memory
  + Binning Mode: 一个RenderPasss需要分Binning Pass和Rendering Pass两次完成.
    + 把RenderTarget分割为多个小块Tile, Qualcomm把这些Tile称为bin
    + GPU有一个独立的快速缓存为GMEM, bin的大小由GMEM大小除以RenderTarget的格式(包括深度格式)和大小来决定
    + Binning Pass, 执行简化版VS, 获取所有三角形的可见和不可见和位于哪个bin等信息
    + Render Pass, 逐个bin渲染到GMEM, 使用Binning Pass的信息进行粗粒度的剔除, 渲染完毕后Store到System Memory
    + Binning Mode也分两种. Software Binning 和 Hardware Visibility Binning
    + 当顶点数量非常少的时候, 会用Software Binning来渲染, 用CPU来计算Binning信息
  + Hardware Visibility Direction: 先绘制BinningPass, 之后把全部Bin一次性渲染到System Memory
    + 比较新的平台使用, 如8Gen1/2/3等
    + 遮挡关系复杂用BinningPass来处理
    + 如果后面的Bin逐个渲染不如Direction快, 就一次性渲染
  + Snapdragon Profiler, 鼠标停留在Surface的时候, 可以看到用哪个Render Mode
  + 正常情况是驱动自行判断和选择用哪个Render Mode. 但是GL上有hint函数可以指定, VK暂时没有(后续可能会添加)

#### **1.1.2. Tile-Based Rendering优化**
  + 顶点数量通常不是瓶颈, 但是VS里面计算Position过于复杂或者有依赖, 如采样SSBO或Texture, 则会对性能产生较大的影响
    + 因为前面的Rendering Mode会因为Binning Mode出现跑两次VS的情况
    + 优化建议: 使用LOD降低顶点数量
  + HardWare Occlusion Query
    + HardWare Occlusion Query 在Direction Mode比Binning Mode要好很多.
    + 优化建议: 单独把HardWare Occlusion Query放到一个RenderPass, 然后驱动就会检测到这个RenderPass全是Occlusion Query从而去使用到Direction Mode
    + 比如: 先绘制Opaque,AlphaTest,Transparent之后执行GL.Flush. 再执行Occlusion Query. 堡垒之夜因为这个优化性能提升20%.
    + 8Gen3后这个优化就不怎么重要, 因为做了特殊处理
  + Primitive Restart
    + [Primitive Restart是什么?][2]
    + Primitive Restart对Binning Rendering不友好
    + 优化建议: 不推荐使用
#### **1.1.3. Tile-Based Rendering读写**

-----------------
[1]:https://github.com/HHHHHHHHHHHHHHHHHHHHHCS/MyStudyNote/blob/main/MyNote/%E5%86%99%E8%BD%AE%E7%9C%BC%E4%B8%AACapsuleAO.md
[2]:https://www.khronos.org/opengl/wiki/Vertex_Rendering#Primitive_Restart