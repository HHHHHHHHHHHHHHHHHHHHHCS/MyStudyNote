移动端渲硬件特性提升游戏上限
======

(Github正常排版: [移动端渲硬件特性提升游戏上限][1])

-----------------

这个其实是UOD的免费视频 [视频地址][2]. 讲的东西我基本都没有学习过! 

这篇很多特性都是Metal(Apple)的, 虽然一些安卓厂商也出了其中一些特性.

UWA太贵了加上游戏太好玩了, 后面就挑几个感兴趣的看吧.

-----------------


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [**0. 大纲**](#0-大纲)
- [**1. Metal Binary Archive**](#1-metal-binary-archive)
  - [**1.1 Shader编译**](#11-shader编译)
  - [**1.2 离线编译**](#12-离线编译)
  - [**1.3 第一版编译**](#13-第一版编译)
  - [**1.4 第二版编译**](#14-第二版编译)
  - [**1.5 效果**](#15-效果)
  - [**1.6 Reference**](#16-reference)
- [**2. Metal Variable Rate Rasterization Rate Map**](#2-metal-variable-rate-rasterization-rate-map)

<!-- /code_chunk_output -->


-----------------

## **0. 大纲**
  + Metal Binary Archive
  + Metal Variable Rate Rasterization Rate Map
  + Vulkan Variable Rate Shading
  + Metal Async Compute
  + Stencil_ID Lighting Pass
  + Metal Multi_Threaded Rendering
  + Metal Lossless & Lossy
  + Metal Frame Pacing

-----------------

## **1. Metal Binary Archive**

### **1.1 Shader编译**

  主要是编译Shader导致的Loading的卡顿问题.

![](Images/MobileHardware_00.jpg)

正常模式:
  1. Command buffer encoding -- 执行命令
  2. PSO creation -- PSO创建, 申请编译Shader
  3. Shader binary generation -- 正式执行Shader编译
当执行Shader编译花费大量时间的时候, 会导致Loading卡顿严重

老方法 Warmup:
  1. 把Shader提前编译好
  2. PSO creation
  3. 加载编译好的Shader
如果Shader Binary过大, 那么Loading的时候会IO会增加很多时间

新方法 Aysnc Compile:
  1. 由另外一个线程执行Shader编译
  2. 没有编译好Shader的物体不绘制

### **1.2 离线编译**

![](Images/MobileHardware_01.jpg)

  + PC
    + 打包时, 提前把Shader编译好, 一起打进包体
  + OpenGLES
    + 老的OpenGLES不支持离线编译
    + OpenGLES3.0开始支持离线编译Shader
    + 编译后的文件叫Program Binary, 以extension的形式存在的
    + 缺点: 不同编译器不同芯片不兼容, 需要为每个芯片每个操作系统单独生成一份Program Binary
  + Metal:
    + 苹果2014放弃了OpenGL, 使用了Metal
    + Metal使用PSO, 比Program性能更好状态更多更好管理 (UE使用PSO)
    + 离线编译后的文件叫Binary Archive
    + Binary Archive第一版
      + A9 Iphone6S IOS14开始支持
      + 缺点: 不同编译器版本支持不支持
    + Binary Archive第二版
      + A13 Iphone11 IOS16开始支持
      + 可以一套支持多个芯片

### **1.3 第一版编译**

  第一版(A9 Iphone6S IOS14)的编译过程.

![](Images/MobileHardware_02.jpg)

  第一步 先通过Metal Shading Language 翻译成 AIR. 第二步 AIR 再翻译成 Binary. 这两步都需要大量的时间.

  第一步可以在离线打包的时候完成. 但是第二步必须在运行时执行.

![](Images/MobileHardware_03.jpg)

  收集: 
  1. 先打一个普通的包, 在游戏运行时候编译PSO
  2. 通过代码创建Binary Archive, 让它的URL为 nil
  3. 然后通过AddRenderPipelineFunction, 把PSO 和 Binary Archive关联在一起
  4. 把Binary Archive存下来

  使用:
  1. 使用URL指定刚才创建好的Binary Archive文件
  2. 创建PSO的时候指定Binary Archive
  3. 生成PSO的时候会从Binary Archive中查找是否又合适的
  4. 如果有则直接使用, 不触发Shader编译
  5. 如果没有则触发Shader编译

### **1.4 第二版编译**

  第二版(A13 Iphone11 IOS16)的编译过程. 跟第一版有点相似.

![](Images/MobileHardware_04.jpg)

  收集:
  1. 先执行第一版Binary Archive 储存
  2. 执行命令, 生成json(可手写)
  3. 把Json和Shader代码(或AIR文件)给XCODE
  4. 用命令生成第二版的Binary Archive

  使用:
  1. 和第一版一样

  第二版如何兼容多个操作系统和芯片的?
  
  苹果系统会在安装APP或升级操作系统的时候, 编译/升级 Binary Archive, 来保证向前兼容. 因为升级是在后台异步完成的, 所以对用户来说是无感的.

### **1.5 效果**

![](Images/MobileHardware_05.jpg)

用Binary Barchive 的编译时间是 Air 的 1/20. WWDC上说可以到1/28

每个Binary Barchive的大小约10KB, 4468PSO未压缩共121MB. 占用的是包体而非内存. Binary Barchive使用后可以立即销毁, 不会占用内存.

### **1.6 Reference**
  
  + [WWDC2020 Build GPU binaries with Metal][3]
  + [WWDC2021 Discover compilation workflows in Metal][4]
  + [WWDC2022 Target and optimize GPU binaries with Metal 3][4]
  + [AppleDeveloper MTLBinaryArchive][5]

可以看到苹果这三年都在推BinaryArchive.

-----------------

## **2. Metal Variable Rate Rasterization Rate Map**

-----------------

[1]:https://github.com/HHHHHHHHHHHHHHHHHHHHHCS/MyStudyNote/
[2]:https://www.bilibili.com/video/BV1aW4y1x7CA
[3]:https://developer.apple.com/videos/play/wwdc2020/10615
[4]:https://developer.apple.com/videos/play/wwdc2021/10229
[5]:https://developer.apple.com/videos/play/wwdc2022/10102
[6]:https://developer.apple.com/documentation/metal/mtlbinaryarchive?language=objc